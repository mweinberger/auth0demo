"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_js_1 = __importDefault(require("./base.js"));
const types_js_1 = require("../types.js");
const arweave_js_1 = require("../utils/arweave.js");
const verification_js_1 = require("../utils/verification.js");
const utils_js_1 = require("../utils/utils.js");
const errors_js_1 = require("../errors.js");
const SupportedFields = ["actor", "action", "status", "source", "target", "timestamp"];
const SupportedJSONFields = ["message", "new", "old"];
/**
 * AuditService class provides methods for interacting with the Audit Service
 * @extends BaseService
 */
class AuditService extends base_js_1.default {
    constructor(token, config) {
        super("audit", token, config);
        this.publishedRoots = {};
        this.publishedRoots = {};
        this.apiVersion = "v1";
        this.prevUnpublishedRootHash = undefined;
    }
    /**
     * @summary Log an entry
     * @description Create a log entry in the Secure Audit Log.
     * @param {Object} content - A structured event describing an auditable activity. Supported fields are:
     *   - actor (string): Record who performed the auditable activity.
     *   - action (string): The auditable action that occurred.
     *   - status (string): Record whether or not the activity was successful.
     *   - source (string): Used to record the location from where an activity occurred.
     *   - target (string): Used to record the specific record that was targeted by the auditable activity.
     *   - message (string|object): A message describing a detailed account of what happened.
     *     This can be recorded as free-form text or as a JSON-formatted string.
     *   - new (string|object): The value of a record after it was changed.
     *   - old (string|object): The value of a record before it was changed.
     * @param {Object} options - Log options. The following log options are supported:
     *   - verbose (bool): Return a verbose response, including the canonical event hash and received_at time.
     * @returns {Promise} - A promise representing an async call to the log endpoint.
     * @example
     * ```js
     * const auditData = {
     *    action: "add_employee",
     *    actor: user,
     *    target: data.email,
     *    status: "error",
     *    message: `Resume denied - sanctioned country from ${clientIp}`,
     *    source: "web",
     *  };
     *
     *  const logResponse = await audit.log(auditData);
     * ```
     */
    log(content, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const event = {
                message: "",
            };
            SupportedFields.forEach((key) => {
                if (key in content) {
                    // @ts-ignore
                    event[key] = content[key];
                }
            });
            SupportedJSONFields.forEach((key) => {
                if (key in content) {
                    // @ts-ignore
                    event[key] =
                        // @ts-ignore
                        content[key] instanceof Object
                            ? // @ts-ignore
                                JSON.stringify(content[key])
                            : // @ts-ignore
                                (event[key] = content[key]);
                }
            });
            const data = { event: event };
            if (options.signer && options.signMode == types_js_1.Audit.SignOptions.Local) {
                const signer = options.signer;
                const eventJson = (0, utils_js_1.canonicalize)(event);
                const signature = signer.sign(eventJson);
                const pubKey = signer.getPublicKey();
                data.signature = signature;
                data.public_key = pubKey;
            }
            if (options === null || options === void 0 ? void 0 : options.verbose) {
                data.verbose = options.verbose;
            }
            if (options === null || options === void 0 ? void 0 : options.verify) {
                data.verbose = true;
                if (this.prevUnpublishedRootHash != undefined) {
                    data.prev_root = this.prevUnpublishedRootHash;
                }
            }
            const response = yield this.post("log", data);
            return this.processLogResponse(response, options);
        });
    }
    processLogResponse(response, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!response.success) {
                return response;
            }
            let newUnpublishedRootHash = response.result.unpublished_root;
            if (!(options === null || options === void 0 ? void 0 : options.skipEventVerification)) {
                this.verifyHash(response.result.envelope, response.result.hash);
                response.result.signature_verification = (0, verification_js_1.verifySignature)(response.result.envelope);
            }
            if (options === null || options === void 0 ? void 0 : options.verify) {
                response.result.membership_verification = (0, verification_js_1.verifyLogMembershipProof)({
                    log: response.result,
                    newUnpublishedRootHash: newUnpublishedRootHash,
                });
                response.result.consistency_verification = (0, verification_js_1.verifyLogConsistencyProof)({
                    log: response.result,
                    newUnpublishedRoot: newUnpublishedRootHash,
                    prevUnpublishedRoot: this.prevUnpublishedRootHash,
                });
            }
            if (newUnpublishedRootHash !== undefined) {
                this.prevUnpublishedRootHash = newUnpublishedRootHash;
            }
            return response;
        });
    }
    verifyHash(envelope, hash) {
        if (envelope === undefined || hash === undefined) {
            return;
        }
        if (!(0, verification_js_1.verifyLogHash)(envelope, hash)) {
            throw new errors_js_1.PangeaErrors.AuditEventError("Error: Fail event hash verification. Hash: " + hash, envelope);
        }
    }
    /**
     * @summary Search for events
     * @description Search for events that match the provided search criteria.
     * @param {String} query - Natural search string; list of keywords with optional
     *   `<option>:<value>` qualifiers. The following optional qualifiers are supported:
     *   - action:
     *   - actor:
     *   - message:
     *   - new:
     *   - old:
     *   - status:
     *   - target:
     * @param {Object} options - Search options. The following search options are supported:
     *   - limit (number): Maximum number of records to return per page.
     *   - start (string): The start of the time range to perform the search on.
     *   - end (string): The end of the time range to perform the search on. All records up to the latest if left out.
     *   - sources (array): A list of sources that the search can apply to. If empty or not provided, matches only the default source.
     * @returns {Promise} - A promise representing an async call to the search endpoint
     * @example
     * ```js
     * const response = await audit.search("add_employee:Gumby")
     * ```
     */
    search(query, queryOptions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const defaults = {
                limit: 20,
                order: "desc",
                order_by: "received_at",
            };
            const payload = { query };
            Object.assign(payload, defaults);
            Object.assign(payload, queryOptions);
            if (options === null || options === void 0 ? void 0 : options.verifyConsistency) {
                payload.verbose = true;
            }
            const response = yield this.post("search", payload);
            return this.processSearchResponse(response, options);
        });
    }
    /**
     * @summary Results of a search
     * @description Fetch paginated results of a previously executed search
     * @param {String} id - The id of a successful search
     * @param {number} limit (default 20) - The number of results returned
     * @param {number} offset (default 0) - The starting position of the first returned result
     * @param {boolean} verifyResponse (default false) - Verify consistency and membership proof of every record
     * @returns {Promise} - A promise representing an async call to the results endpoint
     * @example
     * ```js
     * const response = await audit.results(pxx_asd0987asdas89a8, 50, 100)
     * ```
     */
    results(id, limit = 20, offset = 0, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!id) {
                throw new Error("Missing required `id` parameter");
            }
            const payload = {
                id,
                limit,
                offset,
            };
            const response = yield this.post("results", payload);
            return this.processSearchResponse(response, options);
        });
    }
    /**
     * @summary Retrieve tamperproof verification
     * @description Returns current root hash and consistency proof
     * @param {number} size - The size of the tree (the number of records)
     * @returns {Promise} - A promise representing an async call to the results endpoint
     * @example
     * ```js
     * const response = audit.root(7);
     * ```
     */
    root(size = 0) {
        const data = {};
        if (size > 0) {
            data.tree_size = size;
        }
        return this.post("root", data);
    }
    processSearchResponse(response, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!response.success) {
                return response;
            }
            const localRoot = (treeSize) => __awaiter(this, void 0, void 0, function* () {
                const response = yield this.root(treeSize);
                const root = response.result.data;
                return root;
            });
            if (!(options === null || options === void 0 ? void 0 : options.skipEventVerification)) {
                response.result.events.forEach((record) => {
                    this.verifyHash(record.envelope, record.hash);
                    record.signature_verification = (0, verification_js_1.verifySignature)(record.envelope);
                });
            }
            if (options === null || options === void 0 ? void 0 : options.verifyConsistency) {
                const root = response.result.root;
                if (root !== undefined) {
                    const treeName = root === null || root === void 0 ? void 0 : root.tree_name;
                    const treeSizes = new Set();
                    treeSizes.add((_a = root === null || root === void 0 ? void 0 : root.size) !== null && _a !== void 0 ? _a : 0);
                    response.result.events.forEach((record) => {
                        if (record.leaf_index !== undefined) {
                            const idx = Number(record.leaf_index);
                            treeSizes.add(idx + 1);
                            if (idx > 0) {
                                treeSizes.add(idx);
                            }
                        }
                    });
                    this.publishedRoots = yield (0, arweave_js_1.getArweavePublishedRoots)(treeName, Array.from(treeSizes), localRoot);
                }
                response.result.events.forEach((record) => {
                    record.membership_verification = (0, verification_js_1.verifyRecordMembershipProof)({
                        root: record.published ? root : response.result.unpublished_root,
                        record: record,
                    });
                    record.consistency_verification = (0, verification_js_1.verifyRecordConsistencyProof)({
                        publishedRoots: this.publishedRoots,
                        record: record,
                    });
                });
            }
            return response;
        });
    }
}
exports.default = AuditService;
