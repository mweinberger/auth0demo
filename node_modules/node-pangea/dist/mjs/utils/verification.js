// Copyright 2021 Pangea Cyber Corporation
// Author: Pangea Cyber Corporation
import CryptoJS from "crypto-js";
import MerkleTools from "merkle-tools";
import { canonicalize } from "./utils.js";
// @ts-ignore
const merkleTools = new MerkleTools();
export function verifyLogHash(envelope, hash) {
    var sha256 = CryptoJS.algo.SHA256.create();
    sha256.update(canonicalize(envelope));
    const calcHash = sha256.finalize().toString();
    return calcHash == hash;
}
const decodeHash = (value) => {
    return CryptoJS.enc.Hex.parse(value);
};
const hashPair = (hash1, hash2) => {
    var sha256 = CryptoJS.algo.SHA256.create();
    sha256.update(hash1);
    sha256.update(hash2);
    return sha256.finalize().toString();
};
const decodeProof = (data) => {
    const proof = [];
    data.split(",").forEach((item) => {
        const parts = item.split(":");
        proof.push({
            side: parts[0] == "l" ? "left" : "right",
            nodeHash: decodeHash(parts[1]),
        });
    });
    return proof;
};
const constructProof = (data) => {
    // @ts-ignore
    const proofs = data.split(",").map((item) => {
        const parts = item.split(":");
        const side = parts[0] == "l" ? "left" : "right";
        return {
            [side]: parts[1],
        };
    });
    return proofs;
};
const decodeRootProof = (data) => {
    const rootProof = [];
    data.forEach((item) => {
        const [nodeHash, ...proofData] = item.split(",");
        rootProof.push({
            nodeHash: decodeHash(nodeHash.split(":")[1]),
            proof: decodeProof(proofData.join(",")),
        });
    });
    return rootProof;
};
const verifyLogProof = (initialNodeHash, rootHash, proofs) => {
    let nodeHash = initialNodeHash;
    for (let idx = 0; idx < proofs.length; idx++) {
        const proofHash = proofs[idx].nodeHash;
        nodeHash = decodeHash(proofs[idx].side === "left" ? hashPair(proofHash, nodeHash) : hashPair(nodeHash, proofHash));
    }
    return nodeHash.toString() === rootHash.toString();
};
export const verifyMembershipProof = ({ record, root, }) => {
    if (!record.membership_proof)
        return false;
    if (!record.hash)
        return false;
    const proofs = constructProof(record.membership_proof);
    return merkleTools.validateProof(
    // @ts-ignore
    proofs, record.hash, root.root_hash);
};
export const verifyConsistencyProof_ = ({ newRoot, prevRoot, }) => {
    if (!newRoot || !prevRoot) {
        return false;
    }
    const prevRootHash = decodeHash(prevRoot.root_hash);
    const newRootHash = decodeHash(newRoot.root_hash);
    const consistencyProof = decodeRootProof(newRoot.consistency_proof);
    let rootHash = consistencyProof[0].nodeHash;
    consistencyProof.forEach((rootProof, idx) => {
        if (idx === 0)
            return;
        rootHash = decodeHash(hashPair(rootProof.nodeHash, rootHash));
    });
    if (rootHash.toString() !== prevRootHash.toString()) {
        return false;
    }
    for (var idx = 0; idx < consistencyProof.length; idx++) {
        const rootProof = consistencyProof[idx];
        if (!verifyLogProof(rootProof.nodeHash, newRootHash, rootProof.proof)) {
            return false;
        }
    }
    return true;
};
export const verifyConsistencyProof = ({ publishedRoots, record, }) => {
    const leafIndex = Number(record.leaf_index);
    const newRoot = publishedRoots[leafIndex + 1];
    const prevRoot = publishedRoots[leafIndex];
    return verifyConsistencyProof_({ newRoot, prevRoot, record });
};
