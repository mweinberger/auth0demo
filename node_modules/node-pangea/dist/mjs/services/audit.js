import BaseService from "./base.js";
import { getArweavePublishedRoots } from "../utils/arweave.js";
import { verifyConsistencyProof, verifyLogHash, verifyMembershipProof, } from "../utils/verification.js";
import { Verifier } from "../utils/signer.js";
import { canonicalize } from "../utils/utils.js";
import { PangeaErrors } from "../errors.js";
const SupportedFields = ["actor", "action", "status", "source", "target", "timestamp"];
const SupportedJSONFields = ["message", "new", "old"];
/**
 * AuditService class provides methods for interacting with the Audit Service
 * @extends BaseService
 */
class AuditService extends BaseService {
    publishedRoots;
    constructor(token, config) {
        super("audit", token, config);
        this.publishedRoots = {};
        this.configIdHeaderName = "X-Pangea-Audit-Config-ID";
        this.publishedRoots = {};
        this.apiVersion = "v1";
        this.init();
    }
    /**
     * @summary Log an entry
     * @description Create a log entry in the Secure Audit Log.
     * @param {Object} content - A structured event describing an auditable activity. Supported fields are:
     *   - actor (string): Record who performed the auditable activity.
     *   - action (string): The auditable action that occurred.
     *   - status (string): Record whether or not the activity was successful.
     *   - source (string): Used to record the location from where an activity occurred.
     *   - target (string): Used to record the specific record that was targeted by the auditable activity.
     *   - message (string|object): A message describing a detailed account of what happened.
     *     This can be recorded as free-form text or as a JSON-formatted string.
     *   - new (string|object): The value of a record after it was changed.
     *   - old (string|object): The value of a record before it was changed.
     * @param {Object} options - Log options. The following log options are supported:
     *   - verbose (bool): Return a verbose response, including the canonical event hash and received_at time.
     * @returns {Promise} - A promise representing an async call to the log endpoint.
     * @example
     * ```js
     * const auditData = {
     *    action: "add_employee",
     *    actor: user,
     *    target: data.email,
     *    status: "error",
     *    message: `Resume denied - sanctioned country from ${clientIp}`,
     *    source: "web",
     *  };
     *
     *  const logResponse = await audit.log(auditData);
     * ```
     */
    log(content, options = {}) {
        const event = {
            message: "",
        };
        SupportedFields.forEach((key) => {
            if (key in content) {
                // @ts-ignore
                event[key] = content[key];
            }
        });
        SupportedJSONFields.forEach((key) => {
            if (key in content) {
                // @ts-ignore
                event[key] =
                    // @ts-ignore
                    content[key] instanceof Object
                        ? // @ts-ignore
                            JSON.stringify(content[key])
                        : // @ts-ignore
                            (event[key] = content[key]);
            }
        });
        const data = { event: event };
        if (options.signer) {
            const signer = options.signer;
            const eventJson = canonicalize(event);
            const signature = signer.sign(eventJson);
            const pubKey = signer.getPublicKey();
            data.signature = signature;
            data.public_key = pubKey;
        }
        if (options?.return_hash) {
            data.return_hash = options.return_hash;
        }
        if (options?.verbose) {
            data.verbose = options.verbose;
        }
        return this.post("log", data);
    }
    /**
     * @summary Search for events
     * @description Search for events that match the provided search criteria.
     * @param {String} query - Natural search string; list of keywords with optional
     *   `<option>:<value>` qualifiers. The following optional qualifiers are supported:
     *   - action:
     *   - actor:
     *   - message:
     *   - new:
     *   - old:
     *   - status:
     *   - target:
     * @param {Object} options - Search options. The following search options are supported:
     *   - limit (number): Maximum number of records to return per page.
     *   - start (string): The start of the time range to perform the search on.
     *   - end (string): The end of the time range to perform the search on. All records up to the latest if left out.
     *   - sources (array): A list of sources that the search can apply to. If empty or not provided, matches only the default source.
     * @returns {Promise} - A promise representing an async call to the search endpoint
     * @example
     * ```js
     * const response = await audit.search("add_employee:Gumby")
     * ```
     */
    async search(query, queryOptions, options) {
        const defaults = {
            limit: 20,
            order: "desc",
            order_by: "received_at",
            include_membership_proof: false,
            include_hash: false,
            include_root: false,
        };
        const payload = { query };
        Object.assign(payload, defaults);
        Object.assign(payload, queryOptions);
        options.skipEventVerification =
            options.skipEventVerification === undefined ? true : options.skipEventVerification;
        // This would be removed soon.
        payload.include_hash = true;
        if (options?.verifyConsistency) {
            payload.include_membership_proof = true;
            payload.include_root = true;
        }
        const response = await this.post("search", payload);
        return this.processSearchResponse(response, options);
    }
    /**
     * @summary Results of a search
     * @description Fetch paginated results of a previously executed search
     * @param {String} id - The id of a successful search
     * @param {number} limit (default 20) - The number of results returned
     * @param {number} offset (default 0) - The starting position of the first returned result
     * @param {boolean} verifyResponse (default false) - Verify consistency and membership proof of every record
     * @returns {Promise} - A promise representing an async call to the results endpoint
     * @example
     * ```js
     * const response = await audit.results(pxx_asd0987asdas89a8, 50, 100)
     * ```
     */
    async results(id, limit = 20, offset = 0, options) {
        if (!id) {
            throw new Error("Missing required `id` parameter");
        }
        const payload = {
            id,
            limit,
            offset,
        };
        options.skipEventVerification =
            options.skipEventVerification === undefined ? true : options.skipEventVerification;
        const response = await this.post("results", payload);
        return this.processSearchResponse(response, options);
    }
    /**
     * @summary Retrieve tamperproof verification
     * @description Returns current root hash and consistency proof
     * @param {number} size - The size of the tree (the number of records)
     * @returns {Promise} - A promise representing an async call to the results endpoint
     * @example
     * ```js
     * const response = audit.root(7);
     * ```
     */
    root(size = 0) {
        const data = {};
        if (size > 0) {
            data.tree_size = size;
        }
        return this.post("root", data);
    }
    async processSearchResponse(response, options) {
        if (!response.success) {
            return response;
        }
        const root = response.result.root;
        const localRoot = async (treeSize) => {
            const response = await this.root(treeSize);
            const root = response.result.data;
            return root;
        };
        if (options?.skipEventVerification) {
            const v = new Verifier();
            response.result.events.forEach((record) => {
                if (!verifyLogHash(record.envelope, record.hash)) {
                    throw new PangeaErrors.AuditEventError("Error: Fail event hash verification. Hash: " + record.hash, record.envelope);
                }
                if (record.envelope?.signature !== undefined && record.envelope?.public_key !== undefined) {
                    var data = canonicalize(record.envelope.event);
                    if (v.verify(data, record.envelope.signature, record.envelope.public_key)) {
                        record.signature_verification = "pass";
                    }
                    else {
                        throw new PangeaErrors.AuditEventError("Error: Fail event signature verification. Hash: " + record.hash, record.envelope);
                    }
                }
                else {
                    record.signature_verification = "none";
                }
            });
        }
        if (!root) {
            return response;
        }
        if (options?.verifyConsistency) {
            if (!root?.tree_name)
                return response;
            const treeName = root?.tree_name;
            const treeSizes = new Set();
            treeSizes.add(root?.size ?? 0);
            response.result.events.forEach((record) => {
                if (record.leaf_index !== undefined) {
                    const idx = Number(record.leaf_index);
                    treeSizes.add(idx + 1);
                    if (idx > 0) {
                        treeSizes.add(idx);
                    }
                }
            });
            this.publishedRoots = await getArweavePublishedRoots(treeName, Array.from(treeSizes), localRoot);
            response.result.events.forEach((record) => {
                if (record.leaf_index) {
                    const consistency = verifyConsistencyProof({
                        publishedRoots: this.publishedRoots,
                        record: record,
                    });
                    // TODO: Should we do a Enum for this? Or maybe true, false, undefined?
                    record.consistency_verification = consistency ? "pass" : "fail";
                }
                else {
                    record.consistency_verification = "none";
                }
                if (record.membership_proof) {
                    const membership = verifyMembershipProof({
                        root: response.result.root,
                        record: record,
                    });
                    record.membership_verification = membership ? "pass" : "fail";
                }
                else {
                    record.membership_verification = "none";
                }
            });
        }
        return response;
    }
}
export default AuditService;
