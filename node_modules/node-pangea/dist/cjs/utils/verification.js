"use strict";
// Copyright 2021 Pangea Cyber Corporation
// Author: Pangea Cyber Corporation
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyConsistencyProof = exports.verifyConsistencyProof_ = exports.verifyMembershipProof = exports.verifyLogHash = void 0;
const crypto_js_1 = __importDefault(require("crypto-js"));
const merkle_tools_1 = __importDefault(require("merkle-tools"));
const utils_js_1 = require("./utils.js");
// @ts-ignore
const merkleTools = new merkle_tools_1.default();
function verifyLogHash(envelope, hash) {
    var sha256 = crypto_js_1.default.algo.SHA256.create();
    sha256.update((0, utils_js_1.canonicalize)(envelope));
    const calcHash = sha256.finalize().toString();
    return calcHash == hash;
}
exports.verifyLogHash = verifyLogHash;
const decodeHash = (value) => {
    return crypto_js_1.default.enc.Hex.parse(value);
};
const hashPair = (hash1, hash2) => {
    var sha256 = crypto_js_1.default.algo.SHA256.create();
    sha256.update(hash1);
    sha256.update(hash2);
    return sha256.finalize().toString();
};
const decodeProof = (data) => {
    const proof = [];
    data.split(",").forEach((item) => {
        const parts = item.split(":");
        proof.push({
            side: parts[0] == "l" ? "left" : "right",
            nodeHash: decodeHash(parts[1]),
        });
    });
    return proof;
};
const constructProof = (data) => {
    // @ts-ignore
    const proofs = data.split(",").map((item) => {
        const parts = item.split(":");
        const side = parts[0] == "l" ? "left" : "right";
        return {
            [side]: parts[1],
        };
    });
    return proofs;
};
const decodeRootProof = (data) => {
    const rootProof = [];
    data.forEach((item) => {
        const [nodeHash, ...proofData] = item.split(",");
        rootProof.push({
            nodeHash: decodeHash(nodeHash.split(":")[1]),
            proof: decodeProof(proofData.join(",")),
        });
    });
    return rootProof;
};
const verifyLogProof = (initialNodeHash, rootHash, proofs) => {
    let nodeHash = initialNodeHash;
    for (let idx = 0; idx < proofs.length; idx++) {
        const proofHash = proofs[idx].nodeHash;
        nodeHash = decodeHash(proofs[idx].side === "left" ? hashPair(proofHash, nodeHash) : hashPair(nodeHash, proofHash));
    }
    return nodeHash.toString() === rootHash.toString();
};
const verifyMembershipProof = ({ record, root, }) => {
    if (!record.membership_proof)
        return false;
    if (!record.hash)
        return false;
    const proofs = constructProof(record.membership_proof);
    return merkleTools.validateProof(
    // @ts-ignore
    proofs, record.hash, root.root_hash);
};
exports.verifyMembershipProof = verifyMembershipProof;
const verifyConsistencyProof_ = ({ newRoot, prevRoot, }) => {
    if (!newRoot || !prevRoot) {
        return false;
    }
    const prevRootHash = decodeHash(prevRoot.root_hash);
    const newRootHash = decodeHash(newRoot.root_hash);
    const consistencyProof = decodeRootProof(newRoot.consistency_proof);
    let rootHash = consistencyProof[0].nodeHash;
    consistencyProof.forEach((rootProof, idx) => {
        if (idx === 0)
            return;
        rootHash = decodeHash(hashPair(rootProof.nodeHash, rootHash));
    });
    if (rootHash.toString() !== prevRootHash.toString()) {
        return false;
    }
    for (var idx = 0; idx < consistencyProof.length; idx++) {
        const rootProof = consistencyProof[idx];
        if (!verifyLogProof(rootProof.nodeHash, newRootHash, rootProof.proof)) {
            return false;
        }
    }
    return true;
};
exports.verifyConsistencyProof_ = verifyConsistencyProof_;
const verifyConsistencyProof = ({ publishedRoots, record, }) => {
    const leafIndex = Number(record.leaf_index);
    const newRoot = publishedRoots[leafIndex + 1];
    const prevRoot = publishedRoots[leafIndex];
    return (0, exports.verifyConsistencyProof_)({ newRoot, prevRoot, record });
};
exports.verifyConsistencyProof = verifyConsistencyProof;
